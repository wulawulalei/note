REST（Representational State Transfer）表象化状态转变（表述性状态转变） 

RESTful是一种架构的规范与约束 

RESTful 架构的核心规范与约束：统一接口 



## base64

作用：将不可打印字符（转义字符/控制符）转换成可打印字符，网络传输只能传输可打印字符

31-127



图片转base64优缺点：

1. 网页中使用base64格式的图片时，不用再请求服务器调用图片资源，减少了服务器访问次数。
2. base64格式的文本内容较多，转换后的大小会增加





## 模块化

### common.js

1. 所有代码都运行在模块作用域，不会污染全局作用域
2. 模块中的变量和函数是对当前文件私有的，要在多个文件分享变量则需要定义为global变量
3. 模块可以多次加载，但是只会在第一次加载时运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存
4. module.exports属性表示当前模块对外输出的接口，其他文件加载该模块，实际上就是读取module.exports变量。
5. node为每一个模块提供了一个exports变量(可以说是一个对象)，指向 module.exports。这相当于每个模块中都有一句这样的命令 var exports = module.exports;
6. 如果想得到`require`命令加载的确切文件名，使用`require.resolve()`方法。



```
module对象：
	module.id 模块的识别符，通常是带有绝对路径的模块文件名。
	module.filename 模块的文件名，带有绝对路径。
	module.loaded 返回一个布尔值，表示模块是否已经完成加载。
	module.parent 返回一个对象，表示调用该模块的模块。
	module.children 返回一个数组，表示该模块要用到的其他模块。
	module.exports 表示模块对外输出的值。	
```


## 网络请求部分
1. URL的解析
2. 检查资源缓存
3. DNS解析
4. 建立TCP连接
5. TLS协商密钥
6. 发送请求&接收响应
7. 关闭TCP连接


### URL解析
首先判断输入的内容是URL还是搜索关键字，如果是URL，则会将不完整的URL拼接成一个完整的URL;如果是搜索关键字，则将其拼接到搜索引擎的查询参数部分，这个过程需要将不安全的字符转义成安全的编码（安全字符指的是英文，数字，少数符号）。对非安全字符转义时，使用的是百分号编码，使用一个百分号加上两个十六进制数表示。

### 检查缓存
检查缓存一定是在发起真正的请求之前进行的，只有这样缓存的机制才会生效。如果发现有对应的缓存资源，则去检查缓存的有效期。

在有效期内的缓存资源直接使用，称之为强缓存，从chrome网络面板看到这类请求直接返回200，size是memory cache或者disk cache。memory cache是指从资源从内存中被取出，disk cache是指从磁盘中被取出；从内存中读取比从磁盘中快很多，但资源能不能分配到内存要取决于当下的系统状态。通常来说，刷新页面会使用内存缓存，关闭后重新打开会使用磁盘缓存。

超过有效期的，则携带缓存的资源标识向服务端发起请求，校验是否能继续使用，如果服务端告诉我们，可以继续使用本地存储，则返回304，并且不携带数据；如果服务端告诉我们需要用更新的资源，则返回200，并且携带更新后的资源和资源标识缓存到本地，方便下一次使用。

### DNS解析
如果没有成功使用缓存，则需要发送网路请求。首先是dns解析。
1. 首先是将url地址中的域名切割出来
2. 将切割的域名发送给DNS应用
3. DNS应用带着域名依次搜索浏览器的DNS缓存、操作系统的DNS缓存、路由器的DNS缓存、服务商的DNS服务器查询、全球的根域名服务器查询
4. 该DNS客户机最终会收到一份回答报文，其中包含有该主机名对应的IP地址
5. 一旦该浏览器收到来自DNS的IP地址，就可以向该IP地址定位的HTTP服务器发起TCP连接

### TCP连接（三次握手）
1. 由客户端主动发起握手请求，将TCP报文头部SYN标志位置为1，随机产生一个序号seq=x,发送第一个SYN包给服务器端，客户端从CLOSE状态进入SYN_SENT状态，等待server确认。
2. server端收到来自客户端的数据包后，解析知道了客户端要建立TCP连接的请求，server端将TCP报文头部标志位SYN和ACK都置为1，ack=x+1;并且随机产生一个seq=y,并将数据包发给客户端，server端从LISTEN状态进入SYN_RCVD状态。
3. 客户端收到server端返回的确认后，校验ack=x+1值正确，客户端将标志位ACK置为1，ack=y+1,并把数据包发给server, server端收到ACK包后先校验ack=y+1;如果校验成功,那么成功建立TCP连接；

三次握手原因：倘若客户端发送的是失效的请求，但是服务端已经接受到该请求并准备好内存资源等待请求

### TSL握手
TLS使用的是非对称、对称方式进行加密
握手阶段是使用非对称加密方式进行通信，数据传输时使用对称加密方式进行解密

对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。这种加密方式速度很快，但是问题在于如何让双方知道秘钥。因为 传输数据都是走的网络，如果将秘钥通过网络的方式传递的话，秘钥被截获，就失去了加密的意义。

非对称加密，每个人都有一把公钥和私钥，公钥所有人都可以知道，私钥只有自己知道，将数据用公钥加密，解密必须使用私钥。这种加密方式就可以完美解决对称加密存在的问题，缺点是速度很慢。

我们采取非对称加密的方式协商出一个对称密钥，这个密钥只有发送方和接收方知道的密钥，流程如下：
1. 客户端发送一个随机值以及需要的协议和加密方式；
2. 服务端收到客户端的随机值，发送自己的数字证书，附加上自己产生一个随机值，并根据客户端需求的协议和加密方式使用对应的方式；
3. 客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端；
4. 服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密 钥，接下来的通信就可以通过该对称密钥来加密解密；

### 关闭TCP连接
1. 客户端发送请求释放连接，仅表示客户端不再发送信息
2. 服务端确认释放连接请求，但这时可能还有数据需要处理和发送
3. 服务端请求释放连接，服务端这时不再需要发送数据时
4. 客户端确认连接释放

四次挥手原因：服务端在接收到释放连接请求时，可能还有数据需要处理和发送，因此第二次请求和第三次请求无法合并

### 主动方为什么会等待2MSL
客户端在发送完第四次的确认报文段后会等待2MSL才正真关闭连接，MSL是指数据包在网络中最大的生存时间，目的是确保服务端收到了这个确认报文段。

假设服务端没有收到第四次握手的报文，试想一下会发生什么？在客户端发送第四次握手的数据包后，服务端首先会等待，在1个MSL后，它发现超过了网络中数据包的最大生存时间，但是自己还没有收到数据包，于是服务端认为这个数据包已经丢失了，它决定把第三次握手的数据包重新给客户端发送一次，这个数据包最多花费一个MSL会到达客户端。

一来一去，一共是2MSL，所以客户端在发送完第四次握手数据包后，等待2MSL是一种兜底机制，如果在2MSL内没有收到其他报文段，客户端则认为服务端已经成功接受到第四次挥手，连接正式关闭。

### 把css放在head、js放在body后原因
css资源异步加载，下载和解析不会阻塞DOM树的构建
js资源同步加载，下载和解析会需色DOM树的构建

当在js里面对DOM进行样式的修改且js阻塞到DOM树构建时，CSS会阻塞DOM树的构建

### async、defer
async:异步加载js同步执行js，加载完立即执行，没有顺序
defer:延迟到dom解析完再执行，顺序执行