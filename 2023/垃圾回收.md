## 引用计数

实现原理：内部通过引用计数器，来维护当前对象的引用数，从而判断该对象的引用数是否为0，来决定它是否是一个垃圾对象。如果引用数的值为0，GC就开始工作，将其所在的内存空间进行回收释放和再使用



- 引用计数器

  当某一个对象的引用关系发生改变时，引用计数器就会自动的修改这个对象所对应的引用数值（比如我们代码中有一个对象空间，一个变量引用了它，那么这个对象空间的引用数值加1） 引用数值为0的时候GC就开始工作，将当前的对象空间回收

- 引用计数的优点

  可以即时回收垃圾对象、减少程序卡顿时间。

  发现垃圾立即回收(因为根据当前的引用数值是否为0判断他是否是一个垃圾，如果是垃圾就回收内存空间，释放内存)

  最大限度的减少程序暂停（应用程序在执行的过程中必定会对内存进行消耗，而当前的执行平台内存空间是有上限的，所以内存肯定会有占满的时候。由于引用计数算法时刻监控着那些引用数值为0的对象，当内存爆满的时候会去找那些引用数值为0的对象释放其内存，这个也就保证了当前的内存空间不会有占满的时候）

  

  

  - 引用计数的缺点

  无法回收循环引用的对象
  时间开销大（当前的引用计数需要去维护一个数值的变化，时刻监控当前引用数值是否修改，修改需要时间）



## 标记清除

实现原理
核心思想就是将整个垃圾回收操作分为两个阶段：

1. 遍历所有的对象找到活动对象，进行标记的操作

2. 遍历所有的对象，找到那些没有标记的对象进行清除。(注意在第二阶段中也会把第一阶段涉及的标志给抹掉，便于GC下次能够正常的工作)

   通过两次的遍历行为把我们当前的垃圾空间进行回收，最终交给我们的空闲列表进行维护。

总结：

遍历所有的对象找活动对象做标记
遍历所有的对象清除没有标记的对象
回收相应空间

优点
可以回收循环引用的对象空间。相对于引用计数算法来说：解决对象循环引用的不能回收问题。

缺点
容易产生碎片化空间，浪费空间、不能立即回收垃圾对象。

空间碎片化：所谓空间碎片化就是由于当前所回收的垃圾对象，在地址上面是不连续的，由于这种不连续造成了我们在回收之后分散在各个角落，造成后续使用的问题



## 标记整理

和标记清除一样，只是在清除阶段之前会先执行整理，移动对象位置，使得他们在地址上是一个连续的空间





新生代使用引用计数，老生代使用标记清除和标记整理



新生代转到老生代的条件

1. 数据经历过一次scavenge回收，也就是从from到to
2. to中的空间内存占比超过了25%

```
设置25%的原因：当scavenge回收完成之后，to空间会赋给from空间，接下来的内存分配会在这个空间进行，如果占比过高，在一次scavenge回收之后from空间会变得很小
```





内存分配量和程序占用内存的比例到达一定值时触发垃圾回收机制





## v8内存限制

在64位操作系统中可以使用1.4G内存

在32位操作系统中可以使用0.7G内存



## 限制内存大小的原因

- 1.4G内存完全一次垃圾收集需要一秒以上
- 这个暂停时间成为stop the world，在这个期间，应用的性能和响应能力都会下降