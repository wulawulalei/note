## 判断数据类型的方法



## Object.is和‘===’区别

1. Object.is将+0和-0和0视为不等，===则视为相等
2. Object.is将NaN视为相等，===视为不等



## js继承方法



## 浏览器缓存机制



## sessionStorage存在哪里



## 怎么解决跨域（cors原理、中间件）



## vue父子组件的生命周期执行顺序



## 如何让vue中的data回到初始化

```
this.$data = this.$options.data();
this.form = this.$options.data().form
```



## keep-alive运行机制，实现原理(LRU)

 keep-alive包裹动态组件`component`时，会缓存不活动的组件实例，而不是销毁它们，这样在组件切换过程中将状态保留在内存中，防止重复渲染DOM。 

 结合属性`include`和`exclude`可以明确指定缓存哪些组件或排除缓存指定组件。 



keep-alive是一个通用组件，它内部定义了一个`map`，缓存创建过的组件实例，它返回的渲染函数内部会查找内嵌的component组件对应组件的`vnode`，如果该组件在map中存在就直接返回它。由于component的is属性是个**响应式**数据，因此只要它变化，keep-alive的`render`函数就会重新执行。



 keep-alive自身组件不会被渲染到页面上，那是怎么做到的呢？其实就是通过判断组件实例上的`abstract`的属性值，如果是true的话，就跳过该实例，该实例也不会出现在父级链上。 

```
// src/core/instance/lifecycle.js

export function initLifecycle (vm: Component) {
  const options = vm.$options
  // 找到第一个非abstract的父组件实例
  let parent = options.parent
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }
  vm.$parent = parent
  // ...
}
```



## 生命周期中钩子可以做什么不可以做什么



## 订阅者发布者模式



## 双向绑定的原理

1. `observe`：遍历 `data` 中的属性，使用 Object.defineProperty的 `get/set` 方法对其进行数据劫持；
2. dep`：每个属性拥有自己的消息订阅器 `dep`，用于存放所有订阅了该属性的观察者对象；`
3. `watcher`：观察者（对象），通过 `dep` 实现对响应属性的监听，监听到结果后，主动触发自己的回调进行响应。



## vue2和vue3的区别



## computed和watch的区别



## computed原理

1. 当组件初始化的时候，`computed` 和 `data` 会分别建立各自的响应系统，`Observer`遍历 `data` 中每个属性设置 `get/set` 数据拦截
2. 初始化 `computed``initComputed`
   1. 注册一个 `watcher` 实例，并在内实例化一个 `Dep` 消息订阅器用作后续收集依赖（比如渲染函数的 `watcher` 或者其他观察该计算属性变化的 `watcher` ）
   2. 调用计算属性时会触发其`Object.defineProperty`的`get`访问器函数
   3. 调用 `watcher.depend()` 方法向自身的消息订阅器 `dep` 的 `subs` 中添加其他属性的 `watcher`
   4. 调用 `watcher` 的 `evaluate` 方法（进而调用 `watcher` 的 `get` 方法）让自身成为其他 `watcher` 的消息订阅器的订阅者，首先将 `watcher` 赋给 `Dep.target`，然后执行 `getter` 求值函数，当访问求值函数里面的属性（比如来自 `data`、`props` 或其他 `computed`）时，会同样触发它们的 `get` 访问器函数从而将该计算属性的 `watcher` 添加到求值函数中属性的 `watcher` 的消息订阅器 `dep` 中，当这些操作完成，最后关闭 `Dep.target` 赋为 `null` 并返回求值函数结果。
3. 当某个属性发生变化，触发 `set` 拦截函数，然后调用自身消息订阅器 `dep` 的 `notify` 方法，遍历当前 `dep` 中保存着所有订阅者 `wathcer` 的 `subs` 数组，并逐个调用 `watcher` 的  `update` 方法，完成响应更新。



## vuex核心属性使用和理解



## vue的传值



## 闭包、作用域、原型链的理解



## promise、async的理解



# 小程序



## 登录逻辑

1. 通过wx.login获取用户的code
2. 将code发给自身后端，让后端去调用微信服务器去读取用户数据
3. 后端把appid、appsecret和code一起发送到微信服务器
4. 微信服务器返回openid和本次登录的session_key
5. 后端从数据库查找openid，如果没有记录则该用户还没有注册
6. 后端将返回的session_key进一步加密后返回给小程序
7. 小程序存储session



## 事件

bind：事件绑定不会阻止冒泡

catch：事件绑定可以阻止冒泡



微信小程序没有wx:show，但有hidden属性

```
<view hidden="{{recommendList}}">111</view>
```



## rpx

小程序规定所有的屏幕宽为750rpx



## 更新运行机制

1. 先获取更新管理器对象
2. 监听向微信后台请求检查更新结果
3. 如果需要更新，则客户端主动触发下载
4. 下载完后提示下载完成以及重启应用

```
checkUpdate(){
	const updateManager = wx.getUpdateManager()
	// 检查更新结果
	updateManager.onCheckForUpdate(res => {
		if(res.hasUpdate){
		// 监听版本更新事件，并主动触发下载，下载成功后回调
			updateManager.onUpdateReady(() => {
				wx.showModal({
					title: '更新提示',
					content: '新版本已经准备好了，是否重启应用',
					success(response){
						if(response.confirm){
							// 强制小程序重启并使用新版本 updateManager.applyUpdate()
						}
					}
				})
			})
		}
	})
}
```



## 生命周期

 onready是页面解析完成之后执行，而onload是在页面所有元素加载完成后执行 

先onload再onshow



## 组件定义和父子传值

1. 在父组件的json文件中如下定义

   ```
     "usingComponents": {
       "NavHeader":"/components/NavHeader/NavHeader"
     }
   ```

   

2. 子组件的json文件中注入"component": true,

##### 父组件向子组件传值

```
<childEle childParams="{{params}}"></childEle>
```

##### 子组件通过properties接收

```
properties: {
	childParams: { type: String }
}
```

##### 子组件调用父组件方法

```
<childEle childParams="{{params}}" bind:childFun="fun"></childEle>
```

```
clickFun(){
	this.triggerEvent('childFun');//如果需要传递参数，直接写在triggerEvent的参数里即可
}
```

父组件调用子组件方法

```
<childEle id="childEle" childParams="{{params}}" bind:childFun="fun"></childEle>

onReady(){
	this.childEle = this.selectComponent('#childEle');
	this.childEle.foo()
}
```



## 小程序性能优化

分为启动性能优化和运行时性能优化

1. 合理使用分包加载

   ```
     "subpackages": [
       {
         "root": "songPackage",
         "pages": [
           "pages/recommendSong/recommendSong",
           "pages/songDetail/songDetail"
         ],
         "independent": true // 是否独立分包，独立分包不需要加载主包，且不依赖主包
       }
     ]
   ```

2. 使用按需注入

   ```
   在小程序启动时，启动页面依赖的所有代码包（主包、分包、插件包、扩展库等）的所有 JS 代码会全部合并注入，包括其他未访问的页面以及未用到自定义组件，同时所有页面和自定义组件的 JS 代码会被立刻执行。
   {
     "lazyCodeLoading": "requiredComponents"
   }
   ```

3. 首屏体验优化



1. 合理使用setData

2. 预加载下个页面

   ```
   "preloadRule": {
       "pages/index/index": {
         "packages": ["songPackage", "other"]
       }
     }
   ```

3. 控制资源大小



## 小程序的支付实现

1. 打开电商小程序，搜索浏览到某雕肥皂，点击查看详情后，发现大小、丝滑程度都很合适，点击直接下单
2. wx.login获取用户临时登录凭证code，发送到后端服务器换取openId
3. 在下单时，小程序需要将小明购买的商品Id，商品数量，以及小明这个用户的openId传送到服务器
4. 服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息(必须字段信息将在下文进行详细说明)
5. 小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付



## 小程序的双向绑定和vue的区别



## 实现下拉刷新有哪几种方法

1. 使用小程序默认的onPullDownRefresh方法
2. 监听scroll-view滑动到顶部



## 各种机型的适配



## 精度丢失问题如何解决



## vue组件报错如何监听





# 并发并行

   并发是指一个处理器同时处理多个任务。 
  并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。  



 flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性 