## BFC（块级格式化上下文）

定义：一个BFC区域包含创建该上下文元素中的所有子元素，但是不包括子元素中的子元素。BFC是一块独立的渲染区域，不同的BFC区域之间是相互独立的，互不影响的。



生成BFC的方法：

1. 设置浮动，不包括none
2. 设置定位，包括absolute，fixed
3. 设置overflow，包括hidden，auto，scroll
4. 行内快显示模式，即inline-block
5. 表格单元格，即table-ceil



作用：

1. 解决外边距塌陷问题
2. 解决包含塌陷（子元素margin影响到父元素）
3. 清除浮动
4. 阻止标准流元素被浮动元素覆盖



## 判断数据类型的方法



## Object.is和‘===’区别

1. Object.is将+0和-0和0视为不等，===则视为相等
2. Object.is将NaN视为相等，===视为不等



## js继承方法



## 浏览器缓存机制



## sessionStorage存在哪里



## 怎么解决跨域（cors原理、中间件）



## vue父子组件的生命周期执行顺序



## 如何让vue中的data回到初始化

```
this.$data = this.$options.data();
this.form = this.$options.data().form
```



## keep-alive运行机制，实现原理(LRU)

 keep-alive包裹动态组件`component`时，会缓存不活动的组件实例，而不是销毁它们，这样在组件切换过程中将状态保留在内存中，防止重复渲染DOM。 

 结合属性`include`和`exclude`可以明确指定缓存哪些组件或排除缓存指定组件。 



keep-alive是一个通用组件，它内部定义了一个`map`，缓存创建过的组件实例，它返回的渲染函数内部会查找内嵌的component组件对应组件的`vnode`，如果该组件在map中存在就直接返回它。由于component的is属性是个**响应式**数据，因此只要它变化，keep-alive的`render`函数就会重新执行。



 keep-alive自身组件不会被渲染到页面上，那是怎么做到的呢？其实就是通过判断组件实例上的`abstract`的属性值，如果是true的话，就跳过该实例，该实例也不会出现在父级链上。 

```
// src/core/instance/lifecycle.js

export function initLifecycle (vm: Component) {
  const options = vm.$options
  // 找到第一个非abstract的父组件实例
  let parent = options.parent
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent
    }
    parent.$children.push(vm)
  }
  vm.$parent = parent
  // ...
}
```



## 生命周期中钩子可以做什么不可以做什么



## 订阅者发布者模式



## 双向绑定的原理

1. `observe`：遍历 `data` 中的属性，使用 Object.defineProperty的 `get/set` 方法对其进行数据劫持；
2. dep`：每个属性拥有自己的消息订阅器 `dep`，用于存放所有订阅了该属性的观察者对象；`
3. `watcher`：观察者（对象），通过 `dep` 实现对响应属性的监听，监听到结果后，主动触发自己的回调进行响应。



## vue2和vue3的区别



## computed和watch的区别



## computed原理

1. 当组件初始化的时候，`computed` 和 `data` 会分别建立各自的响应系统，`Observer`遍历 `data` 中每个属性设置 `get/set` 数据拦截
2. 初始化 `computed``initComputed`
   1. 注册一个 `watcher` 实例，并在内实例化一个 `Dep` 消息订阅器用作后续收集依赖（比如渲染函数的 `watcher` 或者其他观察该计算属性变化的 `watcher` ）
   2. 调用计算属性时会触发其`Object.defineProperty`的`get`访问器函数
   3. 调用 `watcher.depend()` 方法向自身的消息订阅器 `dep` 的 `subs` 中添加其他属性的 `watcher`
   4. 调用 `watcher` 的 `evaluate` 方法（进而调用 `watcher` 的 `get` 方法）让自身成为其他 `watcher` 的消息订阅器的订阅者，首先将 `watcher` 赋给 `Dep.target`，然后执行 `getter` 求值函数，当访问求值函数里面的属性（比如来自 `data`、`props` 或其他 `computed`）时，会同样触发它们的 `get` 访问器函数从而将该计算属性的 `watcher` 添加到求值函数中属性的 `watcher` 的消息订阅器 `dep` 中，当这些操作完成，最后关闭 `Dep.target` 赋为 `null` 并返回求值函数结果。
3. 当某个属性发生变化，触发 `set` 拦截函数，然后调用自身消息订阅器 `dep` 的 `notify` 方法，遍历当前 `dep` 中保存着所有订阅者 `wathcer` 的 `subs` 数组，并逐个调用 `watcher` 的  `update` 方法，完成响应更新。



## vuex核心属性使用和理解



## vue的传值



## 闭包、作用域、原型链的理解



## promise、async的理解



# 小程序



## 登录逻辑

1. 通过wx.login获取用户的code
2. 将code发给自身后端，让后端去调用微信服务器去读取用户数据
3. 后端把appid、appsecret和code一起发送到微信服务器
4. 微信服务器返回openid和本次登录的session_key
5. 后端从数据库查找openid，如果没有记录则该用户还没有注册
6. 后端将返回的session_key进一步加密后返回给小程序
7. 小程序存储session



## 事件

bind：事件绑定不会阻止冒泡

catch：事件绑定可以阻止冒泡



微信小程序没有wx:show，但有hidden属性

```
<view hidden="{{recommendList}}">111</view>
```



## rpx

小程序规定所有的屏幕宽为750rpx



## 更新运行机制

1. 先获取更新管理器对象
2. 监听向微信后台请求检查更新结果
3. 如果需要更新，则客户端主动触发下载
4. 下载完后提示下载完成以及重启应用

```
checkUpdate(){
	const updateManager = wx.getUpdateManager()
	// 检查更新结果
	updateManager.onCheckForUpdate(res => {
		if(res.hasUpdate){
		// 监听版本更新事件，并主动触发下载，下载成功后回调
			updateManager.onUpdateReady(() => {
				wx.showModal({
					title: '更新提示',
					content: '新版本已经准备好了，是否重启应用',
					success(response){
						if(response.confirm){
							// 强制小程序重启并使用新版本 updateManager.applyUpdate()
						}
					}
				})
			})
		}
	})
}
```



## 生命周期

 onready是页面解析完成之后执行，而onload是在页面所有元素加载完成后执行 

先onload再onshow



## 组件定义和父子传值

1. 在父组件的json文件中如下定义

   ```
     "usingComponents": {
       "NavHeader":"/components/NavHeader/NavHeader"
     }
   ```

   

2. 子组件的json文件中注入"component": true,

##### 父组件向子组件传值

```
<childEle childParams="{{params}}"></childEle>
```

##### 子组件通过properties接收

```
properties: {
	childParams: { type: String }
}
```

##### 子组件调用父组件方法

```
<childEle childParams="{{params}}" bind:childFun="fun"></childEle>
```

```
clickFun(){
	this.triggerEvent('childFun');//如果需要传递参数，直接写在triggerEvent的参数里即可
}
```

父组件调用子组件方法

```
<childEle id="childEle" childParams="{{params}}" bind:childFun="fun"></childEle>

onReady(){
	this.childEle = this.selectComponent('#childEle');
	this.childEle.foo()
}
```



## 小程序性能优化

分为启动性能优化和运行时性能优化

1. 合理使用分包加载

   ```
     "subpackages": [
       {
         "root": "songPackage",
         "pages": [
           "pages/recommendSong/recommendSong",
           "pages/songDetail/songDetail"
         ],
         "independent": true // 是否独立分包，独立分包不需要加载主包，且不依赖主包
       }
     ]
   ```

2. 使用按需注入

   ```
   在小程序启动时，启动页面依赖的所有代码包（主包、分包、插件包、扩展库等）的所有 JS 代码会全部合并注入，包括其他未访问的页面以及未用到自定义组件，同时所有页面和自定义组件的 JS 代码会被立刻执行。
   {
     "lazyCodeLoading": "requiredComponents"
   }
   ```

3. 首屏体验优化



1. 合理使用setData

2. 预加载下个页面

   ```
   "preloadRule": {
       "pages/index/index": {
         "packages": ["songPackage", "other"]
       }
     }
   ```

3. 控制资源大小



## 小程序的支付实现

1. 打开电商小程序，搜索浏览到某雕肥皂，点击查看详情后，发现大小、丝滑程度都很合适，点击直接下单
2. wx.login获取用户临时登录凭证code，发送到后端服务器换取openId
3. 在下单时，小程序需要将小明购买的商品Id，商品数量，以及小明这个用户的openId传送到服务器
4. 服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息(必须字段信息将在下文进行详细说明)
5. 小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付



## 小程序的双向绑定和vue的区别



## 实现下拉刷新有哪几种方法

1. 使用小程序默认的onPullDownRefresh方法
2. 监听scroll-view滑动到顶部



## 各种机型的适配



## 精度丢失问题如何解决



## vue组件报错如何监听





# 并发并行

  并发是指一个处理器同时处理多个任务。 
  并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。  



 flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性 



**现代浏览器在与服务器建立了一个 TCP 连接后是否会在一个 HTTP 请求完成后断开？什么情况下会断开？**

不会断开，只有在请求报头中声明 Connection: close 才会在请求完成后关闭连接

**一个 TCP 连接可以对应几个 HTTP 请求？**

因为一个HTTP请求结束并不会关闭TCP连接，所以一个 TCP 连接是可以发送多个 HTTP 请求的。

**一个 TCP 连接中 HTTP 请求发送可以一起发送么（比如一起发三个请求，再三个响应一起接收）？**

 HTTP/1.1不可以并行，HTTP2 提供了 Multiplexing 多路传输特性，可以在一个 TCP 连接中同时完成多个 HTTP 请求，可以并行

**为什么有的时候刷新页面不需要重新建立 SSL 连接？**

TCP 连接有的时候会被浏览器和服务端维持一段时间，TCP 不需要重新建立，SSL 自然也会用之前的。

**浏览器对同一 Host 建立 TCP 连接到数量有没有限制？**

所以答案是：有。根据浏览器的设置而定，Chrome 最多允许对同一个 Host 建立六个 TCP 连接。不同的浏览器有一些区别。





## TypeScript中?.、??、!、!.、_含义

- ?.可选链，遇到null或者undefined可以立即停止表达式的运行
- ??空值合并运算符，当左侧操作数为null或者undefined时，返回右侧操作数，否则返回左侧操作数
- !、!.非空断言操作符，（x!）将从x值域中排除null和undefined
- _数字分割符，分割符不会改变数值字面量的值，方便读懂数字



## const和readonly区别

1. const用于变量，readonly用于属性
2. const在运行时检查，readonly在编译时检查
3. 使用const变量声明的数组，可以使用push、pop等方法，但是使用ReadonlyArray声明的数组不能使用push、pop等方法



## 泛型

泛型用于未来可重用的组件，一个组件可以支持多种类型的数据。这样就可以以自己传进的数值的据类型去使用组件



## type和interface区别

相同点：

1. 都可以描述一个对象或者函数
2. 都可以使用extends进行扩展，而且两者并不是互相独立的，也就是interface可以extends type，type可以extends interface



不同点：

1. type 可以声明其他类型（联合类型，元组，基础变量）， interface不支持

2. interface可以多次定义，并被视为合并所有成员，type不支持

3. type能使用in关键字生成映射类型，但interface不支持

   ```
   type Keys = 'firstName | lastName'
   
   type DudeType = {
   	[key in keys]: String
   }
   ```

4. 默认导出方式不同。interface支持导出时同时声明，type必须先声明后导出

   ```
   export default interface hhh{}
   
   type hhh = {}
   export default hhh
   ```

5. extends语法不同。

   ```
   interface a{}
   interface b extends a{}
   
   type a = {}
   type b = a & {}
   ```



## 类型兼容性（拿X和Y做比例，X=Y）

1. 接口兼容性：当X中所有属性在Y中都存在时，则X兼容于Y

   ```
   interface X {
     a: any;
     b: any
   }
   
   interface Y {
     a: any;
     b: any;
     c: any
   }
   let x: X = { a: 1, b: 2 }
   let y: Y = { a: 1, b: 2, c: 3 }
   
   x = y // YES
   y = x // ERROR 类型 "X" 中缺少属性 "c"，但类型 "Y" 中需要该属性
   ```

2. 函数兼容性：当Y的每个参数必须能在X里找到对应类型的参数，X返回值类型必须是Y返回值类型的子类型或者相同

   ```
   let a = (x: number, y: number) => {};
   let b = (x?: number, y?: number) => {};
   let c = (...args: number[]) => {};
   // strictNullChecks": true 时
   a = b // 固定参数可以兼容可选参数
   a = c // 固定参数可以兼容剩余参数
   b = c // 可选参数不兼容剩余参数
   b = a // 可选参数不兼容固定参数
   c = a // 剩余参数可以兼容固定参数
   c = b // 剩余参数可以兼容可选参数
   ```

3. 类的兼容性：只有实例的成员会被比较，静态成员和构函数不会被比较

   ```
   class Animal {
     feet: number;
     constructor(name: string, numFeet: number) { }
   }
   
   class Size {
     feet: number;
     constructor(numFeet: number) { }
   }
   
   let a: Animal;
   let s: Size;
   
   a = s;  // YES
   s = a;  // YES
   ```

4. 泛型兼容性：当接口内容为空没有用到泛型的时候是可以兼容的，否则就不可以兼容

   ```
   interface Empty<T> {}
   let x!: Empty<string>
   let y!: Empty<number>
   x = y // YES
   
   interface noEmpty<T> {
     data: T
   }
   let x!: noEmpty<string>
   let y!: noEmpty<number>
   x = y // ERROR 不能将类型“noEmpty<number>”分配给类型“noEmpty<string>”。
   ```

5. 枚举兼容性：枚举类型于数字类型互相兼容，不同枚举类型之间是不兼容的



## 协变、逆变、双变、抗变

1. 协变（X = Y）： Y类型可以赋值给X类型的情况就叫做协变，也可以说是 X 类型兼容 Y 类型 
2. 逆变（function(Y)= function(X)）： 函数X类型可以赋值给函数Y类型 
3. 双变（X = Y；Y = X）: 父类型可以赋值给子类型，子类型可以赋值给父类型，既逆变又协变，叫做“双向协变 "
4. 抗变（不变）： 非父子类型之间不会发生型变，只要类型不一样就会报错 



## TypeScript 中对象展开会有什么副作用吗？ 

1. 展开对象后面的属性会覆盖前面的属性；
2. 仅包含对象自身的可枚举属性，不可枚举的属性将会丢失。



## TypeScript 模块的加载机制

假设有一个导入语句 `import { a } from "moduleA"`; 

1. 首先，编译器会尝试定位需要导入的模块文件，通过绝对或者相对的路径查找方式； 
2. 如果上面的解析失败了，没有查找到对应的模块，编译器会尝试定位一个外部模块声明（.d.ts）； 
3. 最后，如果编译器还是不能解析这个模块，则会抛出一个错误 `error TS2307: Cannot find module 'moduleA'.



## 类型的全局声明和局部声明

如果声明文件内不包含`import、export`，那么这个文件声明的类型就会变成全局声明。反之，若是这个文件包含了`import、export`，那么这个文件包含的类型声明则会是局部声明，不会影响到全局声明。 



## keyof和typeof

1. keyof是将一个类型映射成类型所有成员名称的联合类型

   ```
   interface hhh{
   	name: string
   	age: number
   }
   type p = keyof hhh // "name" | "age"
   ```

2. typeof是根据已有的值获取值的类型

   ```
   interface hhh{
   	name: string
   	age: number
   }
   type p = typeof hhh
   ```

   



## infer

infer可以去推断一个类型变量 ，推断待推断的类型 

infer语法的限制如下：

1. infer只能在条件类型的 extends 子句中使用
2. infer得到的类型只能在true语句中使用